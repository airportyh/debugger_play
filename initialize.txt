GET /1ea897a8-3b20-4966-aeae-add347319aa1 HTTP/1.1
Connection: Upgrade
Host: 127.0.0.1:9229
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Upgrade: WebSocket

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=

..(..NS..*
..b
..:@..l...;F..#M.. I..+
..>I..#[..5U..........{...3...k...=...z...x...z...s...=...~...%...~...m...l...w...e......./.../...~..{"method":"Runtime.executionContextCreated","params":{"context":{"id":1,"origin":"","name":"node[48904]","auxData":{"isDefault":true}}}}..{"id":1,"result":{}}..Cw..8U..aM.7a..o+..9yU.~!..|&..h&..z6..T-2.x&..r,..9oU.z1..haM.90..o&U.9-..~a
......S...7.......'...q...6...4... ... ...........8...'...q...2...i...2...#...i.............`...(...p...&...v...h...a...h...&...e...>....~..{"method":"Debugger.scriptParsed","params":{"scriptId":"2","url":"chakra_shim.js","startLine":0,"startColumn":0,"endLine":829,"endColumn":0,"executionContextId":1,"hash":"FB260B3265CB1B19B909B6814C7C5F3C0224C7C6","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"3","url":"chakra_inspector.js","startLine":0,"startColumn":0,"endLine":273,"endColumn":0,"executionContextId":1,"hash":"74CFF520BA18D603E5C8180588FDCCC95BF49121","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"5","url":"chakra_shim.js","startLine":0,"startColumn":0,"endLine":829,"endColumn":0,"executionContextId":1,"hash":"FB260B3265CB1B19B909B6814C7C5F3C0224C7C6","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}..{"id":2,"result":{}}..{"id":3,"result":{}}..{"id":4,"result":{}}.K{"error":{"code":-32601,"message":"'Profiler.enable' wasn't found"},"id":5}...M...o.w.w.?. .g.".1.o.v.8.t.?.`.9.....q.5.r.9.a.>.?.=.a. .1.6.c.9.v.#.1...n..............7...o...9...n...v...n...L...r...t...y...~...9...z...!.....{"id":6,"result":{}}..{"id":7,"result":{}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"6","url":"internal/bootstrap/loaders.js","startLine":0,"startColumn":0,"endLine":367,"endColumn":0,"executionContextId":1,"hash":"A8712FF112B9D24526BD84044F77D608D100E052","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"7","url":"internal/bootstrap/node.js","startLine":0,"startColumn":0,"endLine":745,"endColumn":0,"executionContextId":1,"hash":"351F309108E285B0C1B7C0F0015DF31CE3F87D91","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"8","url":"events.js","startLine":0,"startColumn":0,"endLine":484,"endColumn":0,"executionContextId":1,"hash":"1BF241D00552E31436C5B1678C9BAB29310B6291","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"9","url":"internal/async_hooks.js","startLine":0,"startColumn":0,"endLine":462,"endColumn":0,"executionContextId":1,"hash":"B87F8B23B1B5BAF27839000728F2BEA8F029A865","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"10","url":"internal/errors.js","startLine":0,"startColumn":0,"endLine":905,"endColumn":0,"executionContextId":1,"hash":"A1BA2A234653C0B058F267D5812AAB262A220A10","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.
{"method":"Debugger.scriptParsed","params":{"scriptId":"11","url":"util.js","startLine":0,"startColumn":0,"endLine":432,"endColumn":0,"executionContextId":1,"hash":"9FE34DF236D1FAF31332D9E04EA3CD145F73A460","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"12","url":"internal/util/inspect.js","startLine":0,"startColumn":0,"endLine":1111,"endColumn":0,"executionContextId":1,"hash":"5936EA906B2E3F8684F483105FBF847003D8BB00","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"13","url":"internal/util.js","startLine":0,"startColumn":0,"endLine":410,"endColumn":0,"executionContextId":1,"hash":"96F24CD0D37B82E9817C070090681672500E1610","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"14","url":"internal/util/types.js","startLine":0,"startColumn":0,"endLine":88,"endColumn":0,"executionContextId":1,"hash":"DE9DB6D344EFB318BBF01073D0E971E6047A65E6","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"15","url":"internal/validators.js","startLine":0,"startColumn":0,"endLine":144,"endColumn":0,"executionContextId":1,"hash":"8A672703B1DA0EF68617B2A379F9FD1938668F50","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"16","url":"internal/encoding.js","startLine":0,"startColumn":0,"endLine":561,"endColumn":0,"executionContextId":1,"hash":"88C6ECB0886739A4C74D97E591AE64A642089624","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.
{"method":"Debugger.scriptParsed","params":{"scriptId":"17","url":"buffer.js","startLine":0,"startColumn":0,"endLine":1123,"endColumn":0,"executionContextId":1,"hash":"9636F6F228635556876DAF24DFD38CAA82D069D6","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"18","url":"internal/buffer.js","startLine":0,"startColumn":0,"endLine":819,"endColumn":0,"executionContextId":1,"hash":"D0E61812E5ADEAE1B4EC5C8336317D628D753BA6","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.!{"method":"Debugger.scriptParsed","params":{"scriptId":"19","url":"internal/process/per_thread.js","startLine":0,"startColumn":0,"endLine":252,"endColumn":0,"executionContextId":1,"hash":"66F2B3A2959A489048A2D567150FAEC8975D5F52","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.'{"method":"Debugger.scriptParsed","params":{"scriptId":"20","url":"internal/process/main_thread_only.js","startLine":0,"startColumn":0,"endLine":172,"endColumn":0,"executionContextId":1,"hash":"5C5BD7E0FEB2B890AC226BD67DF6EE316223AE57","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"21","url":"internal/process/stdio.js","startLine":0,"startColumn":0,"endLine":214,"endColumn":0,"executionContextId":1,"hash":"CCD17230E32E9BA4C7E2C3652F2201774B68E308","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"22","url":"assert.js","startLine":0,"startColumn":0,"endLine":769,"endColumn":0,"executionContextId":1,"hash":"661AF9B0BFC00DF17679DB86D560F9A0B2F7BC32","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"23","url":"internal/assert.js","startLine":0,"startColumn":0,"endLine":277,"endColumn":0,"executionContextId":1,"hash":"F63669C21B5670B058DD4FB09259A33905F6E3C2","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.	{"method":"Debugger.scriptParsed","params":{"scriptId":"24","url":"fs.js","startLine":0,"startColumn":0,"endLine":1859,"endColumn":0,"executionContextId":1,"hash":"91E4FE409C78A7558DBD3981A0ABF4F861ABD014","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"25","url":"path.js","startLine":0,"startColumn":0,"endLine":1541,"endColumn":0,"executionContextId":1,"hash":"865836216937142049B359A68E9E75D83E589932","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"26","url":"internal/constants.js","startLine":0,"startColumn":0,"endLine":54,"endColumn":0,"executionContextId":1,"hash":"ED9DCDE1F3D10B345CA16BA396FEDF1AACBCA764","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"27","url":"internal/fs/streams.js","startLine":0,"startColumn":0,"endLine":387,"endColumn":0,"executionContextId":1,"hash":"06D08FA1FCDF9DE7A60308D6659283672420BEB4","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"28","url":"internal/fs/utils.js","startLine":0,"startColumn":0,"endLine":477,"endColumn":0,"executionContextId":1,"hash":"5517142243163BB02651E6B7214A3CDBC18A7DC2","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"29","url":"stream.js","startLine":0,"startColumn":0,"endLine":84,"endColumn":0,"executionContextId":1,"hash":"7CDB3250C3C71DD6A9B21D15C375922B78DDFD55","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"30","url":"internal/streams/pipeline.js","startLine":0,"startColumn":0,"endLine":93,"endColumn":0,"executionContextId":1,"hash":"B3E9DA12FFF321D7582B9A1030612B0829E30F06","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.#{"method":"Debugger.scriptParsed","params":{"scriptId":"31","url":"internal/streams/end-of-stream.js","startLine":0,"startColumn":0,"endLine":98,"endColumn":0,"executionContextId":1,"hash":"7F9DB403FE802DC81668EB804B1A8D4237857373","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"32","url":"internal/streams/legacy.js","startLine":0,"startColumn":0,"endLine":93,"endColumn":0,"executionContextId":1,"hash":"2E669F43CC4F6384B4E933A0677FFE4830539211","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"33","url":"_stream_readable.js","startLine":0,"startColumn":0,"endLine":1098,"endColumn":0,"executionContextId":1,"hash":"097D2403B399E288B2011D26374182E172115F35","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~."{"method":"Debugger.scriptParsed","params":{"scriptId":"34","url":"internal/streams/buffer_list.js","startLine":0,"startColumn":0,"endLine":174,"endColumn":0,"executionContextId":1,"hash":"425E13811B01EE40CD78E551337205BBBA8852B1","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"35","url":"internal/streams/destroy.js","startLine":0,"startColumn":0,"endLine":90,"endColumn":0,"executionContextId":1,"hash":"234849E2CC0C3C8334FCEE930C57BED1BA2C5AC1","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"36","url":"internal/streams/state.js","startLine":0,"startColumn":0,"endLine":28,"endColumn":0,"executionContextId":1,"hash":"F1D80643352C425121BFDCA6F9132B50F5ABCBA5","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"37","url":"_stream_writable.js","startLine":0,"startColumn":0,"endLine":704,"endColumn":0,"executionContextId":1,"hash":"C9044C507B132903E95BC8D0BE7943CC5CFC9271","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"38","url":"_stream_duplex.js","startLine":0,"startColumn":0,"endLine":141,"endColumn":0,"executionContextId":1,"hash":"0B6F95B09421B9599E9E94701E1A9BF46DFD3C05","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"39","url":"_stream_transform.js","startLine":0,"startColumn":0,"endLine":224,"endColumn":0,"executionContextId":1,"hash":"A7034221F455597630EAE0D338FAEBD75D9B0125","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"40","url":"_stream_passthrough.js","startLine":0,"startColumn":0,"endLine":45,"endColumn":0,"executionContextId":1,"hash":"3E662FB09A16E215A159C7158D23042BE9C2AEE4","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"41","url":"internal/url.js","startLine":0,"startColumn":0,"endLine":1479,"endColumn":0,"executionContextId":1,"hash":"A9C43022791BA7B532F60151C4D6D4DACE030416","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"42","url":"internal/querystring.js","startLine":0,"startColumn":0,"endLine":31,"endColumn":0,"executionContextId":1,"hash":"C72870A2BA9C4F92B49CCA55BEA4D501AB6B8DC4","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"43","url":"trace_mgr.js","startLine":0,"startColumn":0,"endLine":620,"endColumn":0,"executionContextId":1,"hash":"8F7B92300671C7F8C86136E1E68A0AB633C39FD1","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"44","url":"internal/process/warning.js","startLine":0,"startColumn":0,"endLine":150,"endColumn":0,"executionContextId":1,"hash":"350696D0D80A9BD9F73E57042CA2B748AFB8C260","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~. {"method":"Debugger.scriptParsed","params":{"scriptId":"45","url":"internal/process/next_tick.js","startLine":0,"startColumn":0,"endLine":121,"endColumn":0,"executionContextId":1,"hash":"D94E3130A2B5CDC261B392307845A152FACF5274","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"46","url":"internal/process/promises.js","startLine":0,"startColumn":0,"endLine":129,"endColumn":0,"executionContextId":1,"hash":"F818398288178DD6649F131641279C4B3E8A0BE5","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"47","url":"internal/fixed_queue.js","startLine":0,"startColumn":0,"endLine":115,"endColumn":0,"executionContextId":1,"hash":"1B1F76427480E591E58975B073E78D179E173BC0","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~."{"method":"Debugger.scriptParsed","params":{"scriptId":"48","url":"internal/inspector_async_hook.js","startLine":0,"startColumn":0,"endLine":79,"endColumn":0,"executionContextId":1,"hash":"B8F7E6D059A1B6D27BDB47E547461653430F9600","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"49","url":"timers.js","startLine":0,"startColumn":0,"endLine":812,"endColumn":0,"executionContextId":1,"hash":"C79964D2E4196B525B647F555D6F96B46550FAD6","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"50","url":"internal/linkedlist.js","startLine":0,"startColumn":0,"endLine":56,"endColumn":0,"executionContextId":1,"hash":"3E269282E0CE29C4B65775D4B8E28860D97A24E1","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"51","url":"internal/timers.js","startLine":0,"startColumn":0,"endLine":163,"endColumn":0,"executionContextId":1,"hash":"E16F4162E7280432C2FC71122502455AFB04B1F7","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.!{"method":"Debugger.scriptParsed","params":{"scriptId":"52","url":"internal/modules/cjs/loader.js","startLine":0,"startColumn":0,"endLine":819,"endColumn":0,"executionContextId":1,"hash":"9A835FC39066B499DB8CCC51EE05D4346B992080","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"53","url":"vm.js","startLine":0,"startColumn":0,"endLine":410,"endColumn":0,"executionContextId":1,"hash":"0A94AEE17A760E91765B7B165C85AA306751F9C1","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~."{"method":"Debugger.scriptParsed","params":{"scriptId":"54","url":"internal/modules/cjs/helpers.js","startLine":0,"startColumn":0,"endLine":166,"endColumn":0,"executionContextId":1,"hash":"03029A4316C1BA98A7623908C63A5C56EFC4A063","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.
{"method":"Debugger.scriptParsed","params":{"scriptId":"55","url":"console.js","startLine":0,"startColumn":0,"endLine":468,"endColumn":0,"executionContextId":1,"hash":"48DE6470DAF46245310BCFC6B328DA034932BF33","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.	{"method":"Debugger.scriptParsed","params":{"scriptId":"56","url":"tty.js","startLine":0,"startColumn":0,"endLine":153,"endColumn":0,"executionContextId":1,"hash":"1D847A13173D4D23854075845D5C45AB891F6403","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.
{"method":"Debugger.scriptParsed","params":{"scriptId":"57","url":"net.js","startLine":0,"startColumn":0,"endLine":1701,"endColumn":0,"executionContextId":1,"hash":"F25BA9A00D3D15C41F55A92362E80922F31045D5","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"58","url":"internal/net.js","startLine":0,"startColumn":0,"endLine":77,"endColumn":0,"executionContextId":1,"hash":"25996D1107AA591A8C294CD3FD0B41C9000C84A0","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~."{"method":"Debugger.scriptParsed","params":{"scriptId":"59","url":"internal/stream_base_commons.js","startLine":0,"startColumn":0,"endLine":139,"endColumn":0,"executionContextId":1,"hash":"FB09F2A01BFE583167BDE122392FB5A470461BC4","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.scriptParsed","params":{"scriptId":"60","url":"internal/tty.js","startLine":0,"startColumn":0,"endLine":155,"endColumn":0,"executionContextId":1,"hash":"582730A37CDB0170B08F24E4F2F40731FFB34A21","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~.?{"method":"Debugger.scriptParsed","params":{"scriptId":"61","url":"file:///Users/airportyh/Home/Playground/debugger_play/play.js","startLine":0,"startColumn":0,"endLine":10,"endColumn":0,"executionContextId":1,"hash":"262E509095084A28EE7FE3011D1442B69CFAAB52","isLiveEdit":false,"sourceMapURL":"","hasSourceURL":false}}.~..{"method":"Debugger.paused","params":{"callFrames":[{"callFrameId":"{\"ordinal\":0}","functionName":"Anonymous function","functionLocation":{"scriptId":"61","lineNumber":1,"columnNumber":2},"location":{"scriptId":"61","lineNumber":8,"columnNumber":0},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":0,\"name\":\"locals\"}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":0,\"name\":\"globals\"}"}}],"this":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":10}"}},{"callFrameId":"{\"ordinal\":1}","functionName":"Module.prototype._compile","functionLocation":{"scriptId":"52","lineNumber":649,"columnNumber":29},"location":{"scriptId":"52","lineNumber":684,"columnNumber":4},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":1,\"name\":\"locals\"}"}},{"type":"closure","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"handle\":30}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":1,\"name\":\"globals\"}"}}],"this":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":19}"}},{"callFrameId":"{\"ordinal\":2}","functionName":"Module._extensions[.js]","functionLocation":{"scriptId":"52","lineNumber":697,"columnNumber":29},"location":{"scriptId":"52","lineNumber":698,"columnNumber":2},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":2,\"name\":\"locals\"}"}},{"type":"closure","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"handle\":37}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":2,\"name\":\"globals\"}"}}],"this":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":32}"}},{"callFrameId":"{\"ordinal\":3}","functionName":"Module.prototype.load","functionLocation":{"scriptId":"52","lineNumber":589,"columnNumber":25},"location":{"scriptId":"52","lineNumber":597,"columnNumber":2},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":3,\"name\":\"locals\"}"}},{"type":"closure","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"handle\":43}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":3,\"name\":\"globals\"}"}}],"this":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":39}"}},{"callFrameId":"{\"ordinal\":4}","functionName":"tryModuleLoad","functionLocation":{"scriptId":"52","lineNumber":534,"columnNumber":1},"location":{"scriptId":"52","lineNumber":536,"columnNumber":4},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":4,\"name\":\"locals\"}"}},{"type":"closure","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"handle\":50}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":4,\"name\":\"globals\"}"}}],"this":{"type":"undefined","description":"undefined","objectId":"{\"handle\":45}"}},{"callFrameId":"{\"ordinal\":5}","functionName":"Module._load","functionLocation":{"scriptId":"52","lineNumber":501,"columnNumber":16},"location":{"scriptId":"52","lineNumber":528,"columnNumber":2},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":5,\"name\":\"locals\"}"}},{"type":"closure","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"handle\":60}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":5,\"name\":\"globals\"}"}}],"this":{"type":"function","description":"function Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  updateChildren(parent, this, false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}","objectId":"{\"handle\":52}"}},{"callFrameId":"{\"ordinal\":6}","functionName":"Module.runMain","functionLocation":{"scriptId":"52","lineNumber":728,"columnNumber":18},"location":{"scriptId":"52","lineNumber":740,"columnNumber":4},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":6,\"name\":\"locals\"}"}},{"type":"closure","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"handle\":64}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":6,\"name\":\"globals\"}"}}],"this":{"type":"function","description":"function Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  updateChildren(parent, this, false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}","objectId":"{\"handle\":62}"}},{"callFrameId":"{\"ordinal\":7}","functionName":"startup","functionLocation":{"scriptId":"7","lineNumber":30,"columnNumber":3},"location":{"scriptId":"7","lineNumber":285,"columnNumber":8},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":7,\"name\":\"locals\"}"}},{"type":"closure","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"handle\":79}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":7,\"name\":\"globals\"}"}}],"this":{"type":"undefined","description":"undefined","objectId":"{\"handle\":66}"}},{"callFrameId":"{\"ordinal\":8}","functionName":"bootstrapNodeJSCore","functionLocation":{"scriptId":"7","lineNumber":15,"columnNumber":2},"location":{"scriptId":"7","lineNumber":742,"columnNumber":2},"scopeChain":[{"type":"local","object":{"type":"object","className":"Object","description":"Object","objectId":"{\"ordinal\":8,\"name\":\"locals\"}"}},{"type":"global","object":{"type":"object","className":"global","description":"global","objectId":"{\"ordinal\":8,\"name\":\"globals\"}"}}],"this":{"type":"object","description":"null","objectId":"{\"handle\":81}"}}],"reason":"Break on start","hitBreakpoints":[]}}...d...F.l.^.$.	.|...*.F.m...o...o...k.
.|...z...$...z.	.*...{...x.-.*.F.;....~E.{"id":8,"result":{"scriptSource":"(function (exports, require, module, process) {'use strict';\n\n// Disable trace handling inside trace handler to avoid recursion\n// Set to true to prevent action till loading is complete -- set to false at end\nlet reentrantDisable = true;\n\nlet lazyloadDone = false;\nlet path;\nlet fs;\n\n// /////////////////////////////\n// Trace calls\n\n/*\n*Check and emit time travel trace\n* -- invoke remoteTraceManagerObj functions as needed.\n*@emitKind string matching one of the emitOption flags\n*@optInfo additional info we want to pass in (error code for emitOnExit)\n*@result 're-entrant' 'disabled', 'no-sample', 'fail', 'success'\n*/\nfunction emitTrace(emitKind, optInfo) {\n  const res = emitTrace_helper(emitKind, optInfo);\n  if (res.flag === 'success') {\n    // This is an intentional programatic breakpoint\n    // -- it is only triggerable in --replay-debug mode\n    debugger; /* TTD_DEBUG_BREAKPOINT */ // eslint-disable-line no-debugger\n  }\n  res.action();\n}\nexports.emitTrace = emitTrace;\n\nfunction buildTraceResult(flagv, actionv) {\n  const realAction = actionv || function() { };\n  return { flag: flagv, action: realAction };\n}\n\nfunction emitTrace_helper(emitKind, optInfo) {\n  if (reentrantDisable) {\n    return buildTraceResult('re-entrant');\n  }\n\n  reentrantDisable = true;\n  try {\n    if (!global.enabledDiagnosticsTrace || !global.enabledDiagnosticsTrace()) {\n      return buildTraceResult('disabled');\n    }\n\n    if (!checkGlobalShouldEmit(emitKind, optInfo)) {\n      return buildTraceResult('no-sample');\n    }\n\n    if (!lazyloadDone) {\n      path = require('path');\n      fs = require('fs');\n\n      lazyloadDone = true;\n    }\n\n    // Process a synchronous write action for a unique trace bin\n    //  -- otherwise a async action on a multiple trace bin\n    let sampleRes = buildTraceResult('no-sample');\n    if (emitKind === 'emitOnExit' ||\n      emitKind === 'emitOnException' ||\n      emitKind === 'emitOnSigInt') {\n      sampleRes = emitSyncTraceKind(emitKind, optInfo);\n    } else {\n      sampleRes = emitAsyncTraceKind(emitKind);\n    }\n\n    if (sampleRes.flag === 'success') {\n      updateGlobalSampleStats(emitKind);\n    }\n    return sampleRes;\n\n  } catch (ex) {\n    process.stderr.write('Failed in emitTrace with: ' + ex);\n    return buildTraceResult('fail');\n  } finally {\n    reentrantDisable = false;\n  }\n}\n\n// //\n// Helpers for trace calls\nfunction emitSyncTraceKind(emitKind, optInfo) {\n  // build up trace name\n  let traceName = emitKind;\n  if (emitKind === 'emitOnExit') {\n    traceName += ('_code-' + optInfo);\n  }\n\n  // invoke the trace writer and remote manager if needed\n  const resolvedPath = createTraceLogTarget(traceName);\n  if (!resolvedPath) {\n    return buildTraceResult('fail');\n  }\n\n  function action() {\n    try {\n      process.stderr.write(`    Write error trace to: ${resolvedPath}\\n`);\n      global.emitTTDLog(resolvedPath);\n\n      if (emitOptions.remoteTraceManagerObj &&\n        emitOptions.remoteTraceManagerObj.uploadTraceSync) {\n        emitOptions.remoteTraceManagerObj.uploadTraceSync(resolvedPath);\n      }\n    } catch (ex) {\n      process.stderr.write('Failed in emitTrace with: ' + ex);\n    }\n  }\n\n  return buildTraceResult('success', action);\n}\n\nfunction emitAsyncTraceKind(emitKind) {\n  // get trace stack and check if we want to emit\n  const stk = generateFuzzyStack(emitKind);\n  const entry = checkBinShouldEmit(stk);\n  if (!entry) {\n    return buildTraceResult('no-sample');\n  }\n\n  // build up trace name\n  const traceBucketName = `${emitKind}_${stk.fbin}_bucket-${entry.bucketId}`;\n  const traceDirName = `trace-${entry.traceCtr}`;\n  const traceName = path.join(traceBucketName, traceDirName);\n\n  // invoke the trace writer and remote manager if needed\n  const resolvedPath = createTraceLogTarget(traceName);\n  if (!resolvedPath) {\n    return buildTraceResult('fail');\n  }\n\n  function action() {\n    try {\n      process.stderr.write(`    Write error trace to: ${resolvedPath}\\n`);\n      global.emitTTDLog(resolvedPath);\n\n      if (emitOptions.remoteTraceManagerObj &&\n        emitOptions.remoteTraceManagerObj.uploadTraceAsync) {\n        emitOptions.remoteTraceManagerObj.uploadTraceAsync(resolvedPath);\n      }\n    } catch (ex) {\n      process.stderr.write('Failed in emitTrace with: ' + ex);\n    }\n  }\n\n  // update the bin stats as needed\n  updateEmitInfo(entry, resolvedPath);\n  return buildTraceResult('success', action);\n}\n\n// create a directory for emitting the trace (if possible) and return it\nfunction createTraceLogTarget(tracename) {\n  const traceRootDir = emitOptions.localTraceDirectory ||\n    path.dirname(process.mainModule.filename);\n\n  // Add the PID to the trace name\n  tracename = `${tracename}_pid${process.pid}`;\n\n  const resolvedTracePath =\n    path.resolve(traceRootDir, '_diagnosticTraces', tracename);\n\n  // ensure directory exists and is empty...\n  const ok = ensureTraceTarget(resolvedTracePath);\n  if (!ok) {\n    return undefined;\n  }\n\n  return resolvedTracePath;\n}\n\n// ensure directory exists and is empty...\nfunction ensureTraceTarget(pth) {\n  // I don't like this and don't want it to be happening so I am going to bail\n  if (!path.isAbsolute(pth)) {\n    return false;\n  }\n\n  const okdir = createTargetDirectory(pth);\n  if (!okdir) {\n    return false;\n  }\n\n  return deleteTargetDirectoryContents(pth);\n}\n\nfunction createTargetDirectory(pth) {\n  // see if it just exists and, if so, just return true\n  const accessok = fs.constants.R_OK | fs.constants.W_OK | fs.constants.X_OK;\n  try {\n    fs.accessSync(pth, accessok);\n    if (fs.statSync(pth).isDirectory()) {\n      return true;\n    }\n  } catch (ei) { }\n\n  // walk up the directory to see where the first valid part of the path is\n  let prefixPath = pth;\n  const suffixPaths = [];\n  let baseFound = false;\n  do {\n    // check for bad prefix\n    if (prefixPath === path.dirname(prefixPath)) {\n      process.stderr.write(`Failed prefix: ${pth} -\u003E ${prefixPath}\\n`);\n      return false;\n    }\n\n    suffixPaths.push(path.basename(prefixPath)); // reverse order\n    prefixPath = path.dirname(prefixPath);\n\n    try {\n      fs.accessSync(prefixPath, accessok);\n      baseFound = fs.statSync(prefixPath).isDirectory();\n    } catch (ei) { }\n  } while (!baseFound);\n\n  // now extend the prefix with all the suffix parts\n  while (suffixPaths.length \u003E 0) {\n    try {\n      prefixPath = path.resolve(prefixPath, suffixPaths.pop());\n      fs.mkdirSync(prefixPath);\n    } catch (ec) {\n      process.stderr.write(`Failed creating trace directory : ${ec}\\n`);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction deleteTargetDirectoryContents(pth) {\n  try {\n    const items = fs.readdirSync(pth);\n    for (var i = 0; i \u003C items.length; i++) {\n      const fpath = path.resolve(pth, items[i]);\n      const stats = fs.lstatSync(fpath);\n      if (stats.isFile()) {\n        fs.unlinkSync(fpath);\n      } else if (stats.isDirectory()) {\n        const recok = deleteTargetDirectoryContents(fpath);\n        if (!recok) {\n          return false;\n        }\n\n        fs.rmdirSync(fpath);\n      } else {\n        return false; // something strange in here.\n      }\n    }\n  } catch (ex) {\n    process.stderr.write(`Failed cleaning directory contents: ${ex}\\n`);\n    return false;\n  }\n\n  return true;\n}\n\n// after we take a sample update the sampling stats\nfunction updateGlobalSampleStats(eventKind) {\n  currentSampleRate[eventKind] *= emitOptions.backoffFactors[eventKind];\n\n  const updateTime = new Date();\n  emitMinTimeValue.emitOnLogWarn = new Date(updateTime);\n  emitMinTimeValue.emitOnLogError = new Date(updateTime);\n\n  if (eventKind === 'emitOnAssert') {\n    emitMinTimeValue.emitOnAssert = updateTime;\n  }\n}\n\n// /////////////////////////////\n// Trace emit manager code\n\nconst emitOptions = {\n  emitOnExit: 'error', // emit a trace on exit -- off, error, all\n  emitOnException: true, // emit a trace on uncaught execption\n  emitOnSigInt: true, // emit a trace on sigint\n  emitOnLogWarn: true, // check for trace emit on console.warn\n  emitOnLogError: true, // check for trace emit on console.error\n  emitOnAssert: true, // check for trace emit on console.assert or assert\n\n  globalMinInterval: 500, // min interval between console/assert trace emits\n  globalBackoffCancelInterval: 5000, // time when we reset the backoff interval\n\n  // The probability that we sample on the first warn/error/assert encountered\n  initialRates: {\n    emitOnLogWarn: 0.25,\n    emitOnLogError: 0.25,\n    emitOnAssert: 1.0\n  },\n\n  // The baseline background probability that we sample traces\n  baselineRates: {\n    emitOnLogWarn: 0.25,\n    emitOnLogError: 0.25,\n    emitOnAssert: 1.0\n  },\n\n  // backoff factor to apply\n  backoffFactors: {\n    emitOnLogWarn: 0.25,\n    emitOnLogError: 0.5,\n    emitOnAssert: 0.5\n  },\n\n  binMaxSampled: 10, // Max number of traces to take per stack bin\n  binBackoffFactor: 0.5, // sample probability #preserved * binBackoffFactor\n\n  localTraceDirectory: undefined, // The root directory for storing traces\n  remoteTraceManagerObj: undefined // manager object for remote trace support\n};\n\nconst callStackEmitInfoMap = new Map();\nlet bucketCtr = 0;\n\nconst emitMinTimeValue = {\n  emitOnLogWarn: new Date(0),\n  emitOnLogError: new Date(0),\n  emitOnAssert: new Date(0)\n};\n\nconst currentSampleRate = {};\nfor (const srp in emitOptions.initialRates) {\n  currentSampleRate[srp] = emitOptions.initialRates[srp];\n}\n\n/*\n*Update emitOptions from the given options object\n*/\nfunction setOptions(optionsObj) {\n  for (const opt in optionsObj) {\n    // TODO: need more error checking on the validity of the option values\n    emitOptions[opt] = optionsObj[opt];\n  }\n\n  for (const srp in emitOptions.initialRates) {\n    currentSampleRate[srp] = emitOptions.initialRates[srp];\n  }\n}\nexports.setOptions = setOptions;\n\n/*\n*Do a preliminary check if the emitKind is even enabled and to do sampling.\n*@emitKind string matching one of the emitOption flags\n*@optInfo additional info we want to pass in (error code for emitOnExit)\n*@result true if we may want to sample false if we definitely do not\n*/\nfunction checkGlobalShouldEmit(emitKind, optInfo) {\n  // Check if the flag is enabled\n  if (emitKind === 'emitOnExit') {\n    if (emitOptions.emitOnExit === 'all') {\n      return true;\n    } else {\n      return (emitOptions.emitOnExit === 'error') && (optInfo !== 0);\n    }\n  } else if (emitKind === 'emitOnException' || emitKind === 'emitOnSigInt') {\n    return emitOptions[emitKind];\n  } else {\n    if (!emitOptions[emitKind]) {\n      return false;\n    }\n\n    const sampleInterval = new Date() - emitMinTimeValue[emitKind];\n\n    // Don't sample too often no matter what (or we can basically live lock)\n    if (sampleInterval \u003C emitOptions.globalMinInterval) {\n      return false;\n    }\n\n    // Relax our global rate if it has been a while\n    if (sampleInterval \u003E= emitOptions.globalBackoffCancelInterval) {\n      const currRate = currentSampleRate[emitKind];\n      const blRate = emitOptions.baselineRates[emitKind];\n      currentSampleRate[emitKind] = Math.max(currRate, blRate);\n    }\n\n    // Probabalistic check if we want to do sample new trace\n    return Math.random() \u003C currentSampleRate[emitKind];\n  }\n}\n\n/*\n*Given a fuzzy stack see if we want to write a trace for the call\n*@fuzzyStack is the stack produced by getFuzzyCallStack\n*@result if we want to sample return the entry otherwise undefined\n*/\nfunction checkBinShouldEmit(fuzzyStack) {\n  const entry = resolveStackEntry(fuzzyStack);\n\n  // stop sampling after max sampled values -- e.g. we don't need 100 repros\n  if (entry.traceCtr \u003E emitOptions.binMaxSampled) {\n    return undefined;\n  }\n\n  // check if we want to sample on this entry -- we don't need every hit on this\n  const sampleProb = Math.pow(emitOptions.binBackoffFactor, entry.traceCtr);\n  return (Math.random() \u003C sampleProb) ? entry : undefined;\n}\n\n/*\n*Note that we sampled for this entry and update the info as appropriate\n*@sampleEntry the entry we did the sample on\n*@sampleName the sample we are adding\n*/\nfunction updateEmitInfo(sampleEntry, sampleName) {\n  sampleEntry.traceCtr++;\n  sampleEntry.samples.push(sampleName);\n}\n\n// //\n// Helpers for emit manager code\nfunction resolveStackEntry(fuzzyStack) {\n  if (!callStackEmitInfoMap.has(fuzzyStack.hash)) {\n    callStackEmitInfoMap.set(fuzzyStack.hash, []);\n  }\n  const stackList = callStackEmitInfoMap.get(fuzzyStack.hash);\n\n  for (var i = 0; i \u003C stackList.length; ++i) {\n    if (eqFuzzyStacks(fuzzyStack, stackList[i].stack)) {\n      return stackList[i];\n    }\n  }\n\n  stackList.push({\n    stack: fuzzyStack,\n    bucketId: bucketCtr++,\n    traceCtr: 0,\n    samples: []\n  });\n  return stackList[stackList.length - 1];\n}\n\n// /////////////////////////////\n// Fuzzy stack code\n\n// Helper hashcode computation function (dbj2 variant)\nfunction djbHash(str, hash) {\n  for (var i = 0; i \u003C str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  return hash;\n}\n\n// helper is absolute path copied from path -- avoid neededing to require it\nfunction directIsAbsoluteW32(pth) {\n  const len = pth.length;\n  if (len === 0)\n    return false;\n\n  let code = pth.charCodeAt(0);\n  if (code === 47/* / */ || code === 92/* \\ */) {\n    return true;\n  } else if ((code \u003E= 65/* A */ && code \u003C= 90/* Z */) ||\n    (code \u003E= 97/* a */ && code \u003C= 122/* z */)) {\n    // Possible device root\n\n    if (len \u003E 2 && pth.charCodeAt(1) === 58/* : */) {\n      code = pth.charCodeAt(2);\n      if (code === 47/* / */ || code === 92/* \\ */)\n        return true;\n    }\n  }\n  return false;\n}\n\nfunction directIsAbsolutePosix(pth) {\n  return pth.length \u003E 0 && pth.charCodeAt(0) === 47/* / */;\n}\n\nconst directIsAbsolute = (process.platform === 'win32') ?\n  directIsAbsoluteW32 :\n  directIsAbsolutePosix;\n\n/*\n* Create and return a fuzzy stack match for the current call.\n*/\nfunction generateFuzzyStack(eventKind) {\n  // Create an array of the file/lines for user space code in the call stack.\n  // eslint-disable-next-line no-restricted-syntax\n  let errstk = new Error()\n    .stack\n    .split('\\n')\n    .slice(1)\n    .map(function(frame) {\n      return frame.substring(frame.indexOf('(') + 1, frame.lastIndexOf(')'));\n    })\n    .filter(function(frame) {\n      return directIsAbsolute(frame);\n    });\n\n  let fname = 'empty_stack';\n  if (errstk.length !== 0) {\n    const lastframe = errstk[errstk.length - 1];\n    fname = lastframe.substr(lastframe.lastIndexOf(path.sep) + 1)\n      .replace('.js:', '_line-')\n      .replace(':', '_column-');\n  }\n\n  // Identify which frames are recursive (appear multiple times in the stack)\n  const recFrames = new Map();\n  let hasRecFrames = false;\n  for (var i = 0; i \u003C errstk.length; ++i) {\n    if (recFrames.has(errstk[i])) {\n      hasRecFrames = true;\n      recFrames.set(errstk[i], true);\n    } else {\n      recFrames.set(errstk[i], false);\n    }\n  }\n\n  if (hasRecFrames) {\n    // Compress any recursive frames\n    let cpos = 0;\n    let fpos = 0;\n    while (fpos \u003C errstk.length) {\n      if (recFrames.get(errstk[fpos])) {\n        const recArray = [];\n        let spanpos = fpos;\n        let spanend = errstk.lastIndexOf(errstk[fpos]);\n        while (spanpos \u003C= spanend) {\n          if (recArray.indexOf(errstk[spanpos]) === -1) {\n            recArray.push(errstk[spanpos]);\n          }\n\n          spanend = Math.max(spanend, errstk.lastIndexOf(errstk[spanpos]));\n          spanpos++;\n        }\n\n        errstk[cpos] = recArray.sort();\n        fpos = spanend + 1;\n      } else {\n        if (cpos !== fpos) {\n          errstk[cpos] = errstk[fpos];\n        }\n        fpos++;\n      }\n\n      cpos++;\n    }\n\n    errstk = errstk.slice(0, cpos);\n  }\n\n  let chash = 5381;\n  for (i = 0; i \u003C errstk.length; ++i) {\n    if (Array.isArray(errstk[i])) {\n      for (var j = 0; j \u003C errstk[i].length; ++j) {\n        chash = djbHash(errstk[i][j], chash);\n      }\n    } else {\n      chash = djbHash(errstk[i], chash);\n    }\n  }\n\n  return {\n    kind: eventKind,\n    fbin: fname,\n    hash: chash,\n    stack: errstk\n  };\n}\n\n/*\n* Check if 2 fuzzy stacks are equal.\n*/\nfunction eqFuzzyStacks(s1, s2) {\n  if (s1.hash !== s2.hash || s1.stack.length !== s2.stack.length) {\n    return false;\n  }\n\n  for (var i = 0; i \u003C s1.stack.length; ++i) {\n    if (Array.isArray(s1.stack[i]) !== Array.isArray(s2.stack[i])) {\n      return false;\n    }\n\n    if (Array.isArray(s1.stack[i])) {\n      if (s1.stack[i].length !== s2.stack[i].length) {\n        return false;\n      }\n\n      for (var j = 0; j \u003C s1.stack[i].length; ++j) {\n        if (s1.stack[j] !== s2.stack[j]) {\n          return false;\n        }\n      }\n    } else if (s1.stack[i] !== s2.stack[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// /////////////////////////////\n// Bind handlers\n\nfunction onExitHandler(code) {\n  emitTrace('emitOnExit', code);\n}\nexports.onExitHandler = onExitHandler;\n\nfunction onUncaughtExceptionHandler() {\n  emitTrace('emitOnException');\n}\nexports.onUncaughtExceptionHandler = onUncaughtExceptionHandler;\n\nfunction onSigIntHandler(hasUserHandler) {\n  emitTrace('emitOnSigInt');\n\n  if (!hasUserHandler) {\n    // Really exit without triggering any other events\n    process.reallyExit(0);\n  }\n}\nexports.onSigIntHandler = onSigIntHandler;\n\nreentrantDisable = false;\n\n});"}}..gu...W.}EO.5E..m...;]W.|...~...~...z...m4..k...5E..k...;]..j...i.<.;]W.,E...~:x{"id":9,"result":{"scriptSource":"(function (exports, require, module, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  isStackOverflowError,\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM,\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_ARG_VALUE,\n  },\n} = require('internal/errors');\nconst { previewEntries } = process.binding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst util = require('util');\nconst {\n  isTypedArray, isSet, isMap, isSetIterator, isMapIterator,\n} = util.types;\nconst kCounts = Symbol('counts');\nconst trace_mgr = require('trace_mgr'); // ENABLE_TTD\n\nconst {\n  keys: ObjectKeys,\n  values: ObjectValues,\n} = Object;\nconst hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\nconst {\n  isArray: ArrayIsArray,\n  from: ArrayFrom,\n} = Array;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\n\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\n\nfunction Console(options /* or: stdout, stderr, ignoreErrors = true */) {\n  if (!(this instanceof Console)) {\n    return new Console(...arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options,\n      stderr: arguments[1],\n      ignoreErrors: arguments[2]\n    };\n  }\n\n  const {\n    stdout,\n    stderr = stdout,\n    ignoreErrors = true,\n    colorMode = 'auto'\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  var prop = {\n    writable: true,\n    enumerable: false,\n    configurable: true\n  };\n  prop.value = stdout;\n  Object.defineProperty(this, '_stdout', prop);\n  prop.value = stderr;\n  Object.defineProperty(this, '_stderr', prop);\n  prop.value = Boolean(ignoreErrors);\n  Object.defineProperty(this, '_ignoreErrors', prop);\n  prop.value = new Map();\n  Object.defineProperty(this, '_times', prop);\n  prop.value = createWriteErrorHandler(stdout);\n  Object.defineProperty(this, '_stdoutErrorHandler', prop);\n  prop.value = createWriteErrorHandler(stderr);\n  Object.defineProperty(this, '_stderrErrorHandler', prop);\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode', colorMode);\n\n  this[kCounts] = new Map();\n  this[kColorMode] = colorMode;\n\n  Object.defineProperty(this, kGroupIndent, { writable: true });\n  this[kGroupIndent] = '';\n\n  // bind the prototype functions to this Console instance\n  var keys = Object.keys(Console.prototype);\n  for (var v = 0; v \u003C keys.length; v++) {\n    var k = keys[v];\n    this[k] = this[k].bind(this);\n  }\n}\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(stream) {\n  return (err) =\u003E {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error, it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception, but since the handler is\n      // removed after the event, non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.on('error', noop);\n      }\n    }\n  };\n}\n\nfunction write(ignoreErrors, stream, string, errorhandler, groupIndent) {\n  if (groupIndent.length !== 0) {\n    if (string.indexOf('\\n') !== -1) {\n      string = string.replace(/\\n/g, `\\n${groupIndent}`);\n    }\n    string = groupIndent + string;\n  }\n  string += '\\n';\n\n  if (ignoreErrors === false) return stream.write(string);\n\n  // There may be an error occurring synchronously (e.g. for files or TTYs\n  // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so\n  // handle both situations.\n  try {\n    // Add and later remove a noop error handler to catch synchronous errors.\n    stream.once('error', noop);\n\n    stream.write(string, errorhandler);\n  } catch (e) {\n    // console is a debugging utility, so it swallowing errors is not desirable\n    // even in edge cases such as low stack space.\n    if (isStackOverflowError(e))\n      throw e;\n    // Sorry, there's no proper way to pass along the error here.\n  } finally {\n    stream.removeListener('error', noop);\n  }\n}\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\nConsole.prototype[kGetInspectOptions] = function(stream) {\n  let color = this[kColorMode];\n  if (color === 'auto') {\n    color = stream.isTTY && (\n      typeof stream.getColorDepth === 'function' ?\n        stream.getColorDepth() \u003E 2 : true);\n  }\n\n  return color ? kColorInspectOptions : kNoColorInspectOptions;\n};\n\nConsole.prototype[kFormatForStdout] = function(args) {\n  const opts = this[kGetInspectOptions](this._stdout);\n  return util.formatWithOptions(opts, ...args);\n};\n\nConsole.prototype[kFormatForStderr] = function(args) {\n  const opts = this[kGetInspectOptions](this._stderr);\n  return util.formatWithOptions(opts, ...args);\n};\n\nConsole.prototype.log = function log(...args) {\n  write(this._ignoreErrors,\n        this._stdout,\n        this[kFormatForStdout](args),\n        this._stdoutErrorHandler,\n        this[kGroupIndent]);\n};\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\n\nConsole.prototype.warn = function warn(...args) {\n  write(this._ignoreErrors,\n        this._stderr,\n        this[kFormatForStderr](args),\n        this._stderrErrorHandler,\n        this[kGroupIndent]);\n\n  trace_mgr.emitTrace('emitOnLogWarn'); // ENABLE_TTD\n};\nConsole.prototype.error = function error(...args) {\n  write(this._ignoreErrors,\n        this._stderr,\n        util.format.apply(null, args),\n        this._stderrErrorHandler,\n        this[kGroupIndent]);\n  trace_mgr.emitTrace('emitOnLogError'); // ENABLE_TTD\n};\n\nConsole.prototype.dir = function dir(object, options) {\n  options = Object.assign({\n    customInspect: false\n  }, this[kGetInspectOptions](this._stdout), options);\n  write(this._ignoreErrors,\n        this._stdout,\n        util.inspect(object, options),\n        this._stdoutErrorHandler,\n        this[kGroupIndent]);\n};\n\nConsole.prototype.time = function time(label = 'default') {\n  // Coerces everything other than Symbol to a string\n  label = `${label}`;\n  this._times.set(label, process.hrtime());\n};\n\nConsole.prototype.timeEnd = function timeEnd(label = 'default') {\n  // Coerces everything other than Symbol to a string\n  label = `${label}`;\n  const hasWarned = timeLogImpl(this, 'timeEnd', label);\n  if (!hasWarned) {\n    this._times.delete(label);\n  }\n};\n\nConsole.prototype.timeLog = function timeLog(label, ...data) {\n  // Coerces everything other than Symbol to a string\n  label = `${label}`;\n  timeLogImpl(this, 'timeLog', label, data);\n};\n\n// Returns true if label was not found\nfunction timeLogImpl(self, name, label = 'default', data) {\n  const time = self._times.get(label);\n  if (!time) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return true;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n  if (data === undefined) {\n    self.log('%s: %sms', label, ms.toFixed(3));\n  } else {\n    self.log('%s: %sms', label, ms.toFixed(3), ...data);\n  }\n  return false;\n}\n\nConsole.prototype.trace = function trace(...args) {\n  const err = {\n    name: 'Trace',\n    message: this[kFormatForStderr](args)\n  };\n  Error.captureStackTrace(err, trace);\n  this.error(err.stack);\n};\n\nConsole.prototype.assert = function assert(expression, ...args) {\n  if (!expression) {\n    args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n    this.warn(this[kFormatForStderr](args));\n  }\n};\n\n// Defined by: https://console.spec.whatwg.org/#clear\nConsole.prototype.clear = function clear() {\n  // It only makes sense to clear if _stdout is a TTY.\n  // Otherwise, do nothing.\n  if (this._stdout.isTTY) {\n    // The require is here intentionally to avoid readline being\n    // required too early when console is first loaded.\n    const { cursorTo, clearScreenDown } = require('readline');\n    cursorTo(this._stdout, 0, 0);\n    clearScreenDown(this._stdout);\n  }\n};\n\n// Defined by: https://console.spec.whatwg.org/#count\nConsole.prototype.count = function count(label = 'default') {\n  // Ensures that label is a string, and only things that can be\n  // coerced to strings. e.g. Symbol is not allowed\n  label = `${label}`;\n  const counts = this[kCounts];\n  let count = counts.get(label);\n  if (count === undefined)\n    count = 1;\n  else\n    count++;\n  counts.set(label, count);\n  this.log(`${label}: ${count}`);\n};\n\n// Not yet defined by the https://console.spec.whatwg.org, but\n// proposed to be added and currently implemented by Edge. Having\n// the ability to reset counters is important to help prevent\n// the counter from being a memory leak.\nConsole.prototype.countReset = function countReset(label = 'default') {\n  const counts = this[kCounts];\n  counts.delete(`${label}`);\n};\n\nConsole.prototype.group = function group(...data) {\n  if (data.length \u003E 0) {\n    this.log(...data);\n  }\n  this[kGroupIndent] += '  ';\n};\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nConsole.prototype.groupEnd = function groupEnd() {\n  this[kGroupIndent] =\n    this[kGroupIndent].slice(0, this[kGroupIndent].length - 2);\n};\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\n\nconst isArray = (v) =\u003E ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\n// https://console.spec.whatwg.org/#table\nConsole.prototype.table = function(tabularData, properties) {\n  if (properties !== undefined && !ArrayIsArray(properties))\n    throw new ERR_INVALID_ARG_TYPE('properties', 'Array', properties);\n\n  if (tabularData === null || typeof tabularData !== 'object')\n    return this.log(tabularData);\n\n  if (cliTable === undefined) cliTable = require('internal/cli_table');\n  const final = (k, v) =\u003E this.log(cliTable(k, v));\n\n  const inspect = (v) =\u003E {\n    const opt = { depth: 0, maxArrayLength: 3 };\n    if (v !== null && typeof v === 'object' &&\n      !isArray(v) && ObjectKeys(v).length \u003E 2)\n      opt.depth = -1;\n    Object.assign(opt, this[kGetInspectOptions](this._stdout));\n    return util.inspect(v, opt);\n  };\n  const getIndexArray = (length) =\u003E ArrayFrom({ length }, (_, i) =\u003E inspect(i));\n\n  const mapIter = isMapIterator(tabularData);\n  let isKeyValue = false;\n  let i = 0;\n  if (mapIter) {\n    const res = previewEntries(tabularData, true);\n    tabularData = res[0];\n    isKeyValue = res[1];\n  }\n\n  if (isKeyValue || isMap(tabularData)) {\n    const keys = [];\n    const values = [];\n    let length = 0;\n    if (mapIter) {\n      for (; i \u003C tabularData.length / 2; ++i) {\n        keys.push(inspect(tabularData[i * 2]));\n        values.push(inspect(tabularData[i * 2 + 1]));\n        length++;\n      }\n    } else {\n      for (const [k, v] of tabularData) {\n        keys.push(inspect(k));\n        values.push(inspect(v));\n        length++;\n      }\n    }\n    return final([\n      iterKey, keyKey, valuesKey\n    ], [\n      getIndexArray(length),\n      keys,\n      values,\n    ]);\n  }\n\n  const setIter = isSetIterator(tabularData);\n  if (setIter)\n    tabularData = previewEntries(tabularData);\n\n  const setlike = setIter || (mapIter && !isKeyValue) || isSet(tabularData);\n  if (setlike) {\n    const values = [];\n    let length = 0;\n    for (const v of tabularData) {\n      values.push(inspect(v));\n      length++;\n    }\n    return final([setlike ? iterKey : indexKey, valuesKey], [\n      getIndexArray(length),\n      values,\n    ]);\n  }\n\n  const map = {};\n  let hasPrimitives = false;\n  const valuesKeyArray = [];\n  const indexKeyArray = ObjectKeys(tabularData);\n\n  for (; i \u003C indexKeyArray.length; i++) {\n    const item = tabularData[indexKeyArray[i]];\n    const primitive = item === null ||\n        (typeof item !== 'function' && typeof item !== 'object');\n    if (properties === undefined && primitive) {\n      hasPrimitives = true;\n      valuesKeyArray[i] = inspect(item);\n    } else {\n      const keys = properties || ObjectKeys(item);\n      for (const key of keys) {\n        if (map[key] === undefined)\n          map[key] = [];\n        if ((primitive && properties) || !hasOwnProperty(item, key))\n          map[key][i] = '';\n        else\n          map[key][i] = item == null ? item : inspect(item[key]);\n      }\n    }\n  }\n\n  const keys = ObjectKeys(map);\n  const values = ObjectValues(map);\n  if (hasPrimitives) {\n    keys.push(valuesKey);\n    values.push(valuesKeyArray);\n  }\n  keys.unshift(indexKey);\n  values.unshift(indexKeyArray);\n\n  return final(keys, values);\n};\n\nmodule.exports = new Console({\n  stdout: process.stdout,\n  stderr: process.stderr\n});\nmodule.exports.Console = Console;\n\nfunction noop() {}\n\n});"}}....=N..T*...~..P+..R*...
..H)..O`..I...T>..R;..Xl..M/..P=..Fl..O'..t*...{..@3.~..{"id":10,"result":{"scriptSource":"(function (exports, require, module, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst {\n  isIP,\n  isIPv4,\n  isIPv6,\n  isLegalPort,\n  normalizedArgsSymbol,\n  makeSyncWrite\n} = require('internal/net');\nconst assert = require('assert');\nconst {\n  UV_EADDRINUSE,\n  UV_EINVAL\n} = process.binding('uv');\n\nconst { Buffer } = require('buffer');\nconst TTYWrap = process.binding('tty_wrap');\nconst { ShutdownWrap } = process.binding('stream_wrap');\nconst {\n  TCP,\n  TCPConnectWrap,\n  constants: TCPConstants\n} = process.binding('tcp_wrap');\nconst {\n  Pipe,\n  PipeConnectWrap,\n  constants: PipeConstants\n} = process.binding('pipe_wrap');\nconst {\n  newAsyncId,\n  defaultTriggerAsyncIdScope,\n  symbols: { async_id_symbol, owner_symbol }\n} = require('internal/async_hooks');\nconst {\n  createWriteWrap,\n  writevGeneric,\n  writeGeneric,\n  onStreamRead,\n  kUpdateTimer\n} = require('internal/stream_base_commons');\nconst errors = require('internal/errors');\nconst {\n  ERR_INVALID_ADDRESS_FAMILY,\n  ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_FD_TYPE,\n  ERR_INVALID_IP_ADDRESS,\n  ERR_INVALID_OPT_VALUE,\n  ERR_SERVER_ALREADY_LISTEN,\n  ERR_SERVER_NOT_RUNNING,\n  ERR_SOCKET_BAD_PORT,\n  ERR_SOCKET_CLOSED\n} = errors.codes;\nconst { validateInt32, validateString } = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\n\nconst { errnoException, exceptionWithHostPort } = errors;\n\nconst {\n  kTimeout,\n  setUnrefTimeout,\n  validateTimerDuration\n} = require('internal/timers');\n\nfunction noop() {}\n\nfunction createHandle(fd, is_server) {\n  validateInt32(fd, 'fd', 0);\n  const type = TTYWrap.guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nconst debug = util.debuglog('net');\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\n\n\n// Target API:\n//\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options, [cb])\n// connect(port, [host], [cb])\n// connect(path, [cb]);\n//\nfunction connect(...args) {\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  debug('createConnection', normalized);\n  var socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\n\n// Returns an array [options, cb], where options is an object,\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][, cb])\n//   (path[...][, cb])\n//   ([port][, host][...][, cb])\n// For Socket.prototype.connect(), the [...] part is ignored\n// For Server.prototype.listen(), the [...] part is [, backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  var arr;\n\n  if (args.length === 0) {\n    arr = [{}, null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  var options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][, cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][, cb])\n    options.path = arg0;\n  } else {\n    // ([port][, host][...][, cb])\n    options.port = arg0;\n    if (args.length \u003E 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  var cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options, null];\n  else\n    arr = [options, cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// called when creating new Socket, or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n  }\n}\n\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\n\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle, that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this._handle = null;\n  this._parent = null;\n  this._host = null;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = util._extend({}, options);\n\n  options.readable = options.readable || false;\n  options.writable = options.writable || false;\n  const { allowHalfOpen } = options;\n\n  // Prevent the \"no-half-open enforcer\" from being inherited from `Duplex`.\n  options.allowHalfOpen = true;\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  stream.Duplex.call(this, options);\n\n  // Default to *not* allowing half open sockets.\n  this.allowHalfOpen = Boolean(allowHalfOpen);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    this._handle = createHandle(fd, false);\n\n    err = this._handle.open(fd);\n    if (err)\n      throw errnoException(err, 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n    // options.fd can be string (since it is user-defined),\n    // so changing this to === would be semver-major\n    // See: https://github.com/nodejs/node/pull/11513\n    // eslint-disable-next-line eqeqeq\n    if ((fd == 1 || fd == 2) &&\n        (this._handle instanceof Pipe) &&\n        process.platform === 'win32') {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err, 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would, so\n      // we need to let it do that by turning it into a writable, own property.\n      Object.defineProperty(this._handle, 'bytesWritten', {\n        value: 0, writable: true\n      });\n    }\n  }\n\n  // shut down the socket when we're finished with it.\n  this.on('end', onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // handle strings directly\n  this._writableState.decodeStrings = false;\n\n  // if we have a handle, then start the flow of data into the\n  // buffer.  if not, then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nutil.inherits(Socket, stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (var s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\nfunction shutdownSocket(self, callback) {\n  var req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = self._handle;\n  req.callback = callback;\n  return self._handle.shutdown(req);\n}\n\n// the user has called .end(), and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.connecting) {\n    debug('_final: not yet connected');\n    return this.once('connect', () =\u003E this._final(cb));\n  }\n\n  if (!this.readable || this._readableState.ended) {\n    debug('_final: ended, destroy', this._readableState);\n    cb();\n    return this.destroy();\n  }\n\n  debug('_final: not ended, call shutdown()');\n\n  // otherwise, just shutdown, or destroy() if not possible\n  if (!this._handle || !this._handle.shutdown) {\n    cb();\n    return this.destroy();\n  }\n\n  var err = defaultTriggerAsyncIdScope(\n    this[async_id_symbol], shutdownSocket, this, cb\n  );\n\n  if (err)\n    return this.destroy(errnoException(err, 'shutdown'));\n};\n\n\nfunction afterShutdown(status, handle) {\n  var self = handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j', self.destroyed,\n        self._readableState);\n\n  this.callback();\n\n  // callback may come after call to destroy.\n  if (self.destroyed)\n    return;\n\n  if (self._readableState.ended) {\n    debug('readableState ended, destroying');\n    self.destroy();\n  }\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague, and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk, encoding, cb) {\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  var er = new Error('This socket has been ended by the other party');\n  er.code = 'EPIPE';\n  // TODO: defer error events consistently everywhere, not just the cb\n  this.emit('error', er);\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol], process.nextTick, cb, er);\n  }\n}\n\nSocket.prototype.setTimeout = function(msecs, callback) {\n  this.timeout = msecs;\n  // Type checking identical to timers.enroll()\n  msecs = validateTimerDuration(msecs);\n\n  // Attempt to clear an existing timer in both cases -\n  //  even if it will be rescheduled we don't want to leak an existing timer.\n  clearTimeout(this[kTimeout]);\n\n  if (msecs === 0) {\n    if (callback) {\n      this.removeListener('timeout', callback);\n    }\n  } else {\n    this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs);\n\n    if (callback) {\n      this.once('timeout', callback);\n    }\n  }\n  return this;\n};\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize \u003E 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress, so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  if (!this._handle) {\n    this.once('connect',\n              enable ? this.setNoDelay : () =\u003E this.setNoDelay(enable));\n    return this;\n  }\n\n  // backwards compatibility: assume true when `enable` is omitted\n  if (this._handle.setNoDelay)\n    this._handle.setNoDelay(enable === undefined ? true : !!enable);\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(setting, msecs) {\n  if (!this._handle) {\n    this.once('connect', () =\u003E this.setKeepAlive(setting, msecs));\n    return this;\n  }\n\n  if (this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObject.defineProperty(Socket.prototype, '_connecting', {\n  get: function() {\n    return this.connecting;\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'readyState', {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'bufferSize', {\n  get: function() {\n    if (this._handle) {\n      return this[kLastWriteQueueSize] + this.writableLength;\n    }\n  }\n});\n\nObject.defineProperty(Socket.prototype, kUpdateTimer, {\n  get: function() {\n    return this._unrefTimer;\n  }\n});\n\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect', () =\u003E this._read(n));\n  } else if (!this._handle.reading) {\n    // not already reading, start the flow\n    debug('Socket._read readStart');\n    this._handle.reading = true;\n    var err = this._handle.readStart();\n    if (err)\n      this.destroy(errnoException(err, 'read'));\n  }\n};\n\n\nSocket.prototype.end = function(data, encoding, callback) {\n  stream.Duplex.prototype.end.call(this, data, encoding, callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    if (this.writable)\n      this.end();\n  }\n  maybeDestroy(this);\n}\n\n\n// Call whenever we set writable=false or readable=false\nfunction maybeDestroy(socket) {\n  if (!socket.readable &&\n      !socket.writable &&\n      !socket.destroyed &&\n      !socket.connecting &&\n      !socket.writableLength) {\n    socket.destroy();\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this._writableState.finished)\n    this.destroy();\n  else\n    this.once('finish', this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception, cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  this.readable = this.writable = false;\n\n  for (var s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    var isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    this._handle.close(() =\u003E {\n      debug('emit close');\n      this.emit('close', isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n  }\n\n  cb(exception);\n\n  if (this._server) {\n    ;\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._peername) {\n    if (!this._handle || !this._handle.getpeername) {\n      return {};\n    }\n    var out = {};\n    var err = this._handle.getpeername(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name, callback) {\n  Object.defineProperty(Socket.prototype, name, {\n    configurable: false,\n    enumerable: true,\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead', function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress', function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily', function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort', function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  }\n  if (!this._sockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._sockname = out;\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress', function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort', function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\n  // If we are still connecting, then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect', function connect() {\n      this._writeGeneric(writev, data, encoding, cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    this.destroy(new ERR_SOCKET_CLOSED(), cb);\n    return false;\n  }\n\n  this._unrefTimer();\n\n  var req = createWriteWrap(this._handle, afterWrite);\n  if (writev)\n    writevGeneric(this, req, data, cb);\n  else\n    writeGeneric(this, req, data, encoding, cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks, cb) {\n  this._writeGeneric(true, chunks, '', cb);\n};\n\n\nSocket.prototype._write = function(data, encoding, cb) {\n  this._writeGeneric(false, data, encoding, cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious, but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched', function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten', function bytesWritten() {\n  var bytes = this._bytesDispatched;\n  const state = this._writableState;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n\n  if (!state)\n    return undefined;\n\n  this.writableBuffer.forEach(function(el) {\n    if (el.chunk instanceof Buffer)\n      bytes += el.chunk.length;\n    else\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\n  });\n\n  if (Array.isArray(data)) {\n    // was a writev, iterate over chunks to get total length\n    for (var i = 0; i \u003C data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk, chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data, encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction afterWrite(status, handle, err) {\n  var self = handle[owner_symbol];\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite', status);\n\n  if (this.async)\n    self[kLastWriteQueueSize] = 0;\n\n  // callback may come after call to destroy.\n  if (self.destroyed) {\n    debug('afterWrite destroyed');\n    return;\n  }\n\n  if (status \u003C 0) {\n    var ex = errnoException(status, 'write', this.error);\n    debug('write failure', ex);\n    self.destroy(ex, this.callback);\n    return;\n  }\n\n  self._unrefTimer();\n\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite call cb');\n\n  if (this.callback)\n    this.callback.call(undefined);\n}\n\n\nfunction checkBindError(err, port, handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters, a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo, check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\n  // getsockname() method. Non-issue for now, the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port \u003E 0 && handle.getsockname) {\n    var out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError, bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self, address, port, addressType, localAddress, localPort) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  var err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || '0.0.0.0';\n      err = self._handle.bind(localAddress, localPort);\n    } else if (addressType === 6) {\n      localAddress = localAddress || '::';\n      err = self._handle.bind6(localAddress, localPort);\n    } else {\n      self.destroy(new ERR_INVALID_ADDRESS_FAMILY(addressType));\n      return;\n    }\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)',\n          localAddress, localPort, addressType);\n\n    err = checkBindError(err, localPort, self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req, address, port);\n    else\n      err = self._handle.connect6(req, address, port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req, address, afterConnect);\n  }\n\n  if (err) {\n    var sockname = self._getsockname();\n    var details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err, 'connect', address, port, details);\n    self.destroy(ex);\n  }\n}\n\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array, it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342, but was\n  // reverted as it had unintended side effects.\n  if (Array.isArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  var options = normalized[0];\n  var cb = normalized[1];\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._undestroy();\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  var pipe = !!path;\n  debug('pipe', pipe, path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect', cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n  this.writable = true;\n\n  if (pipe) {\n    validateString(path, 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol], internalConnect, this, path\n    );\n  } else {\n    lookupAndConnect(this, options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self, options) {\n  var { port, localAddress, localPort } = options;\n  var host = options.host || 'localhost';\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort && typeof localPort !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('options.localPort', 'number', localPort);\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port',\n                                     ['number', 'string'], port);\n    }\n    if (!isLegalPort(port)) {\n      throw new ERR_SOCKET_BAD_PORT(port);\n    }\n  }\n  port |= 0;\n\n  // If host is an IP, skip performing a lookup\n  var addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol], process.nextTick, () =\u003E {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol],\n          internalConnect,\n          self, host, port, addressType, localAddress, localPort\n        );\n    });\n    return;\n  }\n\n  if (options.lookup && typeof options.lookup !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('options.lookup',\n                                   'Function', options.lookup);\n\n\n  if (dns === undefined) dns = require('dns');\n  var dnsopts = {\n    family: options.family,\n    hints: options.hints || 0\n  };\n\n  if (process.platform !== 'win32' &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host', host);\n  debug('connect: dns options', dnsopts);\n  self._host = host;\n  var lookup = options.lookup || dns.lookup;\n  defaultTriggerAsyncIdScope(self[async_id_symbol], function() {\n    lookup(host, dnsopts, function emitLookup(err, ip, addressType) {\n      self.emit('lookup', err, ip, addressType, host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and\n        // immediately calls net.Socket.connect() on it (that's us).\n        // There are no event listeners registered yet so defer the\n        // error event to the next tick.\n        err.host = options.host;\n        err.port = options.port;\n        err.message = err.message + ' ' + options.host + ':' + options.port;\n        process.nextTick(connectErrorNT, self, err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType);\n        err.host = options.host;\n        err.port = options.port;\n        err.message = err.message + ' ' + options.host + ':' + options.port;\n        process.nextTick(connectErrorNT, self, err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol],\n          internalConnect,\n          self, ip, port, addressType, localAddress, localPort\n        );\n      }\n    });\n  });\n}\n\n\nfunction connectErrorNT(self, err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect', this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect', this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status, handle, req, readable, writable) {\n  var self = handle[owner_symbol];\n\n  // callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  // Update handle if it was wrapped\n  // TODO(indutny): assert that the handle is actually an ancestor of old one\n  handle = self._handle;\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    self.readable = readable;\n    if (!self._writableState.ended)\n      self.writable = writable;\n    self._unrefTimer();\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // start the first read, or get an immediate EOF.\n    // this doesn't actually consume any bytes, because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n\n  } else {\n    self.connecting = false;\n    var details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    var ex = exceptionWithHostPort(status,\n                                   'connect',\n                                   req.address,\n                                   req.port,\n                                   details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\n\nfunction Server(options, connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options, connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection', connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = options || {};\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection', connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n  }\n\n  this._connections = 0;\n\n  Object.defineProperty(this, 'connections', {\n    get: internalUtil.deprecate(() =\u003E {\n\n      if (this._usingWorkers) {\n        return null;\n      }\n      return this._connections;\n    }, 'Server.connections property is deprecated. ' +\n       'Use Server.getConnections method instead.', 'DEP0020'),\n    set: internalUtil.deprecate((val) =\u003E (this._connections = val),\n                                'Server.connections property is deprecated.',\n                                'DEP0020'),\n    configurable: true, enumerable: false\n  });\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n}\nutil.inherits(Server, EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) \u003E= 0 ? x : false; }\n\n// Returns handle if it can be created, or error code if it can't\nfunction createServerHandle(address, port, addressType, fd) {\n  var err = 0;\n  // assign handle in listen, and clean up if bind or listen fails\n  var handle;\n\n  var isTCP = false;\n  if (typeof fd === 'number' && fd \u003E= 0) {\n    try {\n      handle = createHandle(fd, true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:', fd, e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    handle.readable = true;\n    handle.writable = true;\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (process.platform === 'win32') {\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!Number.isNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to', address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6('::', port);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle('0.0.0.0', port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address, port);\n    } else {\n      err = handle.bind(address, port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address, port, addressType, backlog, fd) {\n  debug('setupListenHandle', address, port, addressType, backlog, fd);\n\n  // If there is not yet a handle, we need to create one and bind.\n  // In the case of a server sent via IPC, we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    var rval = null;\n\n    // Try to bind to the unspecified IPv6 address, see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle('::', port, 6, fd);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = '0.0.0.0';\n        addressType = 4;\n      } else {\n        address = '::';\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address, port, addressType, fd);\n\n    if (typeof rval === 'number') {\n      var error = exceptionWithHostPort(rval, 'listen', address, port);\n      process.nextTick(emitErrorNT, this, error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  var err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    var ex = exceptionWithHostPort(err, 'listen', address, port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol],\n                               process.nextTick,\n                               emitErrorNT,\n                               this,\n                               ex);\n    return;\n  }\n\n  // generate connection key, this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol],\n                             process.nextTick,\n                             emitListeningNT,\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\n\nfunction emitListeningNT(self) {\n  // ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server, address, port, addressType,\n                         backlog, fd, exclusive) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isMaster || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n    return;\n  }\n\n  const serverQuery = {\n    address: address,\n    port: port,\n    addressType: addressType,\n    fd: fd,\n    flags: 0\n  };\n\n  // Get the master's server handle, and listen on it\n  cluster._getServer(server, serverQuery, listenOnMasterHandle);\n\n  function listenOnMasterHandle(err, handle) {\n    err = checkBindError(err, port, handle);\n\n    if (err) {\n      var ex = exceptionWithHostPort(err, 'bind', address, port);\n      return server.emit('error', ex);\n    }\n\n    // Reuse master's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  var cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening', cb);\n  }\n  var backlogFromArgs =\n    // (handle, backlog) or (path, backlog) or (port, backlog)\n    toNumber(args.length \u003E 1 && args[1]) ||\n    toNumber(args.length \u003E 2 && args[2]);  // (port, host, backlog)\n\n  options = options._handle || options.handle || options;\n  // (handle[, backlog][, cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this, null, -1, -1, backlogFromArgs);\n    return this;\n  }\n  // (handle[, backlog][, cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd \u003E= 0) {\n    listenInCluster(this, null, null, null, backlogFromArgs, options.fd);\n    return this;\n  }\n\n  // ([port][, host][, backlog][, cb]) where port is omitted,\n  // that is, listen(), listen(null), listen(cb), or listen(null, cb)\n  // or (options[, cb]) where options.port is explicitly set as undefined or\n  // null, bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][, host][, backlog][, cb]) where port is specified\n  // or (options[, cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  var backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    if (!isLegalPort(options.port)) {\n      throw new ERR_SOCKET_BAD_PORT(options.port);\n    }\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this, options.port | 0, options.host, backlog,\n                      options.exclusive);\n    } else { // Undefined host, listens on unspecified address\n      // Default addressType 4 will be used to search for master server\n      listenInCluster(this, null, options.port | 0, 4,\n                      backlog, undefined, options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[, backlog][, cb]) or (options[, cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    var pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this, pipeName, -1, -1,\n                    backlog, undefined, options.exclusive);\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err, 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  throw new ERR_INVALID_OPT_VALUE('options', util.inspect(options));\n};\n\nfunction lookupAndListen(self, port, address, backlog, exclusive) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address, function doListen(err, ip, addressType) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self, ip, port, addressType,\n                      backlog, undefined, exclusive);\n    }\n  });\n}\n\nObject.defineProperty(Server.prototype, 'listening', {\n  get: function() {\n    return !!this._handle;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err, 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  } else {\n    return null;\n  }\n};\n\nfunction onconnection(err, clientHandle) {\n  var handle = this;\n  var self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections \u003E= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  var socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect,\n    readable: true,\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  ;\n  self.emit('connection', socket);\n}\n\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err, connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol],\n                               process.nextTick,\n                               cb,\n                               err,\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null, this._connections);\n    return this;\n  }\n\n  // Poll workers\n  var left = this._workers.length;\n  var total = this._connections;\n\n  function oncount(err, count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null, total);\n  }\n\n  for (var n = 0; n \u003C this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close', function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close', cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    var left = this._workers.length;\n    const onWorkerClose = () =\u003E {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that, even if all sockets will be closed\n    // during polling of workers, `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (var n = 0; n \u003C this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d',\n          !!this._handle, this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol],\n                             process.nextTick,\n                             emitCloseNT,\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\n// Legacy alias on the C++ wrapper object. This is not public API, so we may\n// want to runtime-deprecate it at some point. There's no hurry, though.\nObject.defineProperty(TCP.prototype, 'owner', {\n  get() { return this[owner_symbol]; },\n  set(v) { return this[owner_symbol] = v; }\n});\n\n\nServer.prototype.listenFD = internalUtil.deprecate(function(fd, type) {\n  return this.listen({ fd: fd });\n}, 'Server.listenFD is deprecated. Use Server.listen({fd: \u003Cnumber\u003E}) instead.',\n                                                   'DEP0021');\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit', (socketList) =\u003E {\n    const index = this._workers.indexOf(socketList);\n    this._workers.splice(index, 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nvar _setSimultaneousAccepts;\n\nif (process.platform === 'win32') {\n  var simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {};\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle,\n  _normalizeArgs: normalizeArgs,\n  _setSimultaneousAccepts,\n  connect,\n  createConnection: connect,\n  createServer,\n  isIP: isIP,\n  isIPv4: isIPv4,\n  isIPv6: isIPv6,\n  Server,\n  Socket,\n  Stream: Socket, // Legacy naming\n};\n\n});"}}..bI.[.k.?@s.jNk.>.!.?@s...+.<.,.u.,...;.+.....*.yNk.:.(.(@s.y.*.2.=.?@s.mSk.&.~..{"id":11,"result":{"scriptSource":"(function (exports, require, module, __filename, __dirname) { function doIt() {\n    let a = 1;\n    let b = 2;\n    let c = a * b + 1;\n    let d = c * c + 2;\n    console.log(d);\n}\n\ndoIt();\n});"}}.......W...3...e...2...3.......>...0...%...%...$...'...:...,...=.......u...8...9...u.......:...m...8...$...u... ...8...#...u...;...u...2...%...'...>...9...m...$...9...9...2...8...#.......u...;...u...2...2...!...u..."....~.|{"id":12,"result":{"result":[{"name":"arguments","value":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":124}"},"writable":true,"configurable":false,"enumerable":false},{"name":"exports","value":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":125}"},"writable":true,"configurable":false,"enumerable":false},{"name":"require","value":{"type":"function","description":"function require(path) {\n    try {\n      exports.requireDepth += 1;\n      return mod.require(path);\n    } finally {\n      exports.requireDepth -= 1;\n    }\n  }","objectId":"{\"handle\":126}"},"writable":true,"configurable":false,"enumerable":false},{"name":"module","value":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":127}"},"writable":true,"configurable":false,"enumerable":false},{"name":"__filename","value":{"type":"string","value":"/Users/airportyh/Home/Playground/debugger_play/play.js","description":"/Users/airportyh/Home/Playground/debugger_play/play.js","objectId":"{\"handle\":128}"},"writable":true,"configurable":false,"enumerable":false},{"name":"__dirname","value":{"type":"string","value":"/Users/airportyh/Home/Playground/debugger_play","description":"/Users/airportyh/Home/Playground/debugger_play","objectId":"{\"handle\":129}"},"writable":true,"configurable":false,"enumerable":false},{"name":"doIt","value":{"type":"function","description":"function doIt() {\n    let a = 1;\n    let b = 2;\n    let c = a * b + 1;\n    let d = c * c + 2;\n    console.log(d);\n}","objectId":"{\"handle\":130}"},"writable":true,"configurable":false,"enumerable":false}]}}......;...Re..
2..Vd..Te...S..Oh...f..ks..^s..^r...q..Zl...z..Yk..OH...#...n..Ro..g#...]..Zl...;..Wn..Wr..F#..Tv..In..Iu..H#..Zm...#..Xd..Ts..Tq..Oh..to...;..Wr...o..ro..Cd..In..Iu..HN..B#..Zm...#..Ud..Od..^w..L#..It..F.~.|{"id":13,"result":{"result":[{"name":"arguments","value":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":133}"},"writable":true,"configurable":false,"enumerable":false},{"name":"exports","value":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":134}"},"writable":true,"configurable":false,"enumerable":false},{"name":"require","value":{"type":"function","description":"function require(path) {\n    try {\n      exports.requireDepth += 1;\n      return mod.require(path);\n    } finally {\n      exports.requireDepth -= 1;\n    }\n  }","objectId":"{\"handle\":135}"},"writable":true,"configurable":false,"enumerable":false},{"name":"module","value":{"type":"object","className":"Object","description":"{...}","objectId":"{\"handle\":136}"},"writable":true,"configurable":false,"enumerable":false},{"name":"__filename","value":{"type":"string","value":"/Users/airportyh/Home/Playground/debugger_play/play.js","description":"/Users/airportyh/Home/Playground/debugger_play/play.js","objectId":"{\"handle\":137}"},"writable":true,"configurable":false,"enumerable":false},{"name":"__dirname","value":{"type":"string","value":"/Users/airportyh/Home/Playground/debugger_play","description":"/Users/airportyh/Home/Playground/debugger_play","objectId":"{\"handle\":138}"},"writable":true,"configurable":false,"enumerable":false},{"name":"doIt","value":{"type":"function","description":"function doIt() {\n    let a = 1;\n    let b = 2;\n    let c = a * b + 1;\n    let d = c * c + 2;\n    console.log(d);\n}","objectId":"{\"handle\":139}"},"writable":true,"configurable":false,"enumerable":false}]}}